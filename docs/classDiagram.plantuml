@startuml

    ' Config
    hide empty members
    ' skinparam classAttributeIconSize 0
    ' left to right direction


    ' Pacotes

    package Definitions <<Rectangle>> {
        enum Item
        enum RiverBank
        struct Outcome
    }

    package Domain <<Rectangle>> {
        class Rule
        class State
        class Problem
    }

    package Structure <<Rectangle>> {
        class BasicEdge
        class BasicNode
        class BasicStructure

        package Tree <<Rectangle>> {
            class TreeEdge
            class TreeNode
            class Tree
        }
    }

    package Searches <<Rectangle>> {
        abstract class Search
        abstract class ListsSearch
        class BreadthFirstSearch
        class DepthFirstSearch
        class BacktrackingSearch
    }


    ' Definições

    enum Item {
        Lamp = 0
	    Athlete = 1
	    Boy = 3
	    Lord = 6
	    Woman = 8
	    Lady = 12
    }

    enum RiverBank {
        Initial
        Final
    }

    struct Outcome {
        isTerminal: boolean
        win: boolean
    }


    ' Classes

    class Rule {
        -id: number
        -travellingPeople: Item[]
        +getElapsedTime(): number
        +transpose(state: State): State
    }

    class State {
        -initialRiverBank: Item[]
        -finalRiverBank: Item[]
        -remainingTime: number
        +getValidRules(): Rule[]
        +getOutcome(): Outcome
        +equalByItems(state: State): boolean
        +getLampPosition(): RiverBank
    }

    class Problem {
        -{static}rules: Rule[]
        +{static}getRule(firstPerson: Item, secondPerson?: Item): Rule
        +{static}isSolution(state: State): boolean
    }

    abstract class BasicEdge {
        -sourceNode: BasicNode
        -targetNode: BasicNode
        -rule: Rule
    }

    abstract class BasicNode {
        -id: number
        -state: State
        -targetEdges: BasicEdge[]
        #{abstract}addSourceEdge(sourceNode: BasicNode, rule: Rule): BasicEdge | null
        -addTargetEdge(targetNode: BasicNode, rule: Rule, connect: boolean): BasicEdge
        +addEdge(targetNode: BasicNode, rule: Rule, connect: boolean): BasicEdge
        +connectTargetEdges(targetEdges: BasicEdge[]): void
        +{abstract}checkIfThereIsLoop(state: State): boolean
    }

    abstract class BasicStructure {
        -nextNodeId: number
        #{abstract}instantiateNode(id: number, state: State): BasicNode
        #createNode(state: State): BasicNode
        +{abstract}createValidTransitions(node: BasicNode, sortingFunction: Function): BasicEdge[]
        +{abstract}exportToDot(): string
    }

    class TreeEdge {}

    class TreeNode {
        -sourceEdge: TreeEdge | null
    }

    class Tree {
        -rootNode: TreeNode
        +createNextValidTransition(node: TreeNode, \nsortingFunction: Function): TreeEdge | null
        +{static}getAscendingPath(node: TreeNode): TreeEdge[]
    }

    abstract class Search {
        #tree: Tree
        +getTree(): Tree
        +{static}getAlgorithmName(): string
        +{static}getSafeAlgorithmName(): string
        +{abstract}search(maxIterations?: number): TreeEdge[]
    }

    class BacktrackingSearch {
        {field}-sortingFunction: (Rule, Rule) => number
        -doBacktracking(startNode: TreeNode): \n{foundNode: TreeNode, isSolution: boolean}
    }

    abstract class ListsSearch {
        #currentNode: TreeNode
        #openNodes: TreeNode[]
        #closedNodes: TreeNode[]
        {field}-sortingFunction: (TreeEdge, TreeEdge) => number
        {abstract}+getCurrentNode(): TreeNode
        +getOpenNodes(): TreeNode[]
        +getClosedNodes(): TreeNode[]
        -doIteration(): TreeEdge[] | null
    }


    ' Relacionamentos

    Rule "1" --> "0..n" BasicEdge : Represents
    Problem "1" *-- "1..n" Rule
    BasicNode "1" --> "0..n" BasicEdge : Has Target
    BasicNode "1" --> "1" State : Has State
    TreeNode "1" --> "0..1" TreeEdge : Has source
    Tree "1" --> "1" TreeNode : Has root
    Tree "1" <-- "1" Search : Has tree
    TreeEdge --|> BasicEdge
    TreeNode --|> BasicNode
    Tree --|> BasicStructure
    ListsSearch --|> Search
    BacktrackingSearch --|> Search
    BreadthFirstSearch --|> ListsSearch
    DepthFirstSearch --|> ListsSearch

    Item -[hidden]left- RiverBank
    RiverBank -[hidden]left- Outcome
    ListsSearch --[hidden]down-> Item


@enduml